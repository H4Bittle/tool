[
  {
    "id": "",
    "title": "No Rate Limiting",
    "cvss": "3.6",
    "cvss_vector": "AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H/E:P/RL:O/RC:C/CR:L/IR:L/AR:L/MAV:A/MAC:L/MPR:L/MUI:N/MS:U/MC:L/MI:L/MA:L",
    "severity": "Low",
    "url": "",
    "summary": "During the assessment, it was observed that the APIs do not enforce rate limiting, allowing multiple consecutive requests to be sent without any validation.",
    "description": "The vulnerability relates to the absence of rate limiting controls on the API’s endpoints. Without rate limiting, there is no restriction on the number of requests a user or attacker can send within a given timeframe, leaving the API exposed to automated attacks.\n\nIt was observed that the APIs were exploited for the lack of rate limiting by sending 11,000+ automated requests in rapid succession. This was done using automated tools or scripts, allowing the attacker to perform actions such as creating numerous records, without being blocked or throttled by the server.\n\nAs a result of this vulnerability, the attacker was able to execute the following:\n•\tCreate multiple entries on the system leading to redundancy in data",
    "impact": "The absence of rate limiting on key APIs allows attackers to automate high volumes of requests, enabling mass creation of prompts This results in data redundancy and increased processing overhead, which can strain system resources and require additional maintenance. Over time, this degrades operational efficiency and drives up infrastructure costs, impacting overall service quality and business scalability",
    "recommendation": "It is recommended to implement the following: \n•\tLimit/Throttle requests per user: Prevent excessive requests by setting thresholds or implementing a rate limit for each (e.g., 100 requests/minute).\n•\tUse middleware or framework features to apply limits on all endpoints on the server.\n•\tReturn generic 400 series error messages when limits are exceeded.\n•\tMonitor user and request patterns when rate limiting is triggered to prevent further attacks.",
    "cwe": "",
    "reference": "https://owasp.org/API-Security/editions/2023/en/0xa4-unrestricted-resource-consumption/",
    "steps": []
  },
  {
    "id": "",
    "title": "External DNS Interaction",
    "cvss": "3.2",
    "cvss_vector": "AV:A/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L/E:P/RL:O/RC:C/CR:M/IR:M/AR:M/MAV:A/MAC:L/MPR:N/MUI:R/MS:U/MC:L/MI:N/MA:N",
    "severity": "Low",
    "url": "",
    "summary": "During the assessment, it was observed that the application allows External DNS Interactions through the X-Forwarded-For request header within a WebSocket request",
    "description": "The vulnerability involves improper handling of user-supplied headers in WebSocket requests, specifically the X-Forwarded-For header. When this header is set to an external domain, the application initiates DNS queries to that domain, resulting in external DNS interactions. This behavior can expose internal network information and facilitate further attacks.\nThe attacker crafted a WebSocket request and set the X-Forwarded-For header to a Burp Collaborator URL (an external domain under the attacker’s control). Upon triggering the “Poll now” action, the application made DNS queries to the specified external domain. These queries were captured by the attacker, revealing internal source IP addresses and potentially other sensitive information.\nAs a result, the attacker was able to execute the following:\n•\tObtain internal source IP addresses, aiding in network reconnaissance and infrastructure mapping.\n•\tEstablish a covert channel for leaking sensitive data via unauthorized DNS queries to attacker-controlled domains.\n•\tSignificant exposure of internal network details and compromise the confidentiality and integrity of sensitive information",
    "impact": "The application's handling of user-supplied headers in WebSocket requests allows external DNS interactions, exposing internal source IP addresses to attacker-controlled domains. This compromises internal network confidentiality and increases the risk of targeted attacks, impacting infrastructure security and industry-standard compliance requirements related to data exposure and controlled outbound communication.",
    "recommendation": "It is recommended to implement the following:\n•\tValidate and sanitize all DNS inputs: Ensure that domain or URL inputs used in DNS requests are properly formatted and sanitized to prevent injection or abuse.\n•\tUse allowlists: Only permit DNS requests to a predefined set of domains or subdomains to prevent misuse or data exfiltration.\n•\tLimit DNS request scope: Restrict the type and frequency of DNS queries to minimize attack surface.\n•\tImplement logging and monitoring: Track DNS interactions to detect unusual or unauthorized activity.\n•\tUse secure DNS protocols: Prefer DNS over HTTPS (DoH) or DNS over TLS (DoT) to encrypt DNS queries and enhance privacy.",
    "cwe": "",
    "reference": "https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/13-Testing_for_DNS_Interaction.html\nhttps://portswigger.net/burp/documentation/collaborator",
    "steps": []
  },
  {
    "id": "",
    "title": "Unrestricted File Upload",
    "cvss": "2.1",
    "cvss_vector": "AV:A/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:L/E:P/RL:O/RC:R/CR:L/IR:L/AR:M/MAV:A/MAC:L/MPR:H/MUI:N/MS:U/MC:N/MI:N/MA:L",
    "severity": "Low",
    "url": "",
    "summary": "During the assessment, it was observed that the APIs allow an attacker to bypass content, extension and mime type validations implemented on the file upload endpoint",
    "description": "The APIs permit an attacker to upload malicious files to the “OCR and Embeddings - upload functionalities”. The APIs permits an attacker to bypass the following parameters during the file upload process:\n\n•\tFile Content\n•\tFile Extension\n•\tContent Type\n\nIn this case the APIs does not validate content, extension and content type and allows dangerous file types like bat, exe and php to be uploaded. This lack of validation may allow the introduction of unauthorized or harmful files into the system.. \n\nFile upload vulnerabilities in APIs occur when the server allows files to be uploaded without adequately validating parameters such as file content, file extension and content type. In this case, the API does not sufficiently verify the file extension, content type, or file content. This can lead to the upload of potentially malicious files, posing a risk to the integrity and security of the system.",
    "impact": "Allowing dangerous file types such as .bat, .exe, and .php to be uploaded without proper validation of file content, MIME types, and file extensions introduces security risks. Malicious actors could exploit these gaps to upload harmful scripts or binaries, potentially leading to unauthorized system access, data breaches, malware infections, or service disruptions. If exploited, this vulnerability could result in financial loss, reputational damage, regulatory penalties, and erosion of customer trust.",
    "recommendation": "It is recommended to implement the following validations as per content, extension and MIME type:\n\nFile Content Validation\n•\tReject files containing executable code or scripts, even if they have a permitted extension.\n\n\nFile Extension Validation\n•\tAllow only a whitelist of safe file extensions relevant to your business needs (e.g., .jpg, .png, .pdf).\n•\tBlock double extensions (e.g., file.jpg.php) and files with misleading or hidden extensions.\n•\tNormalize file names to remove special characters and enforce consistent naming conventions.\n\nContent Type (MIME Type) Validation\n•\tCheck the MIME type sent by the client and verify it on the server side.\n•\tDetermine the MIME type independently on the server (e.g., using libraries or built-in functions) and ensure it matches the allowed types.\n•\tReject files with mismatched or suspicious MIME types even if the extension appears valid.",
    "cwe": "",
    "reference": "https://portswigger.net/web-security/file-upload",
    "steps": []
  },
  {
    "id": "",
    "title": "Misconfigured CORS",
    "cvss": "1.7",
    "cvss_vector": "AV:A/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:N/E:P/RL:O/RC:R/CR:L/IR:L/AR:L/MAV:A/MAC:H/MPR:H/MUI:N/MS:U/MC:L/MI:L/MA:N",
    "severity": "Low",
    "url": "",
    "summary": "During the assessment, it was observed that the application implements a misconfigured CORS Policy wherein the Origin header value is reflected in the Access-Control-Allow-Origin response header.",
    "description": "A Cross-Origin Resource Sharing (CORS) misconfiguration occurs when a web application’s CORS policy is too permissive, allowing resources to be accessed from unauthorized or untrusted domains. This can enable malicious websites to interact with the application’s APIs or sensitive data in ways that should not be permitted.\nIt was observed that the input provided by the attacker in the Origin request header is reflected as is in the Access-Control-Allow-Origin response header along with the Access-Control-Allow-Credentials header being set to true, allowing the attacker to set the domain that requests sensitive or authenticated resources from the application. In this case, the application does not reveal sensitive information or share cross-domain information, but allows an attacker to manipulate the origin header and set it to a malicious/attacker controlled domain.\nAs a result, the attacker can potentially fetch the responses of the web application to an attacker controlled domain or request data from sensitive endpoints which may result in the compromise of a user’s data confidentiality.",
    "impact": "The misconfigured CORS policy allows arbitrary Origin values to be reflected in the Access-Control-Allow-Origin response header, creating a misleading trust relationship with unverified domains. While no sensitive data was directly exposed, this weakens browser-enforced access controls and introduces reputational and security risk by enabling attackers to simulate trusted origins, posing a risk to customer trust and security standards.",
    "recommendation": "It is recommended to implement the following:\n•\tAllow only trusted and specific origins to access resources.\n•\tAvoid using wildcard (*) in the Access-Control-Allow-Origin header for sensitive endpoints.\n•\tImplement strict validation of the Origin header on the server side.\n•\tLimit allowed HTTP methods and headers to only those necessary\n•\tRegularly review and test CORS settings as part of the security posture.",
    "cwe": "",
    "reference": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing",
    "steps": []
  },
  {
    "id": "",
    "title": "Improper Input Validation",
    "cvss": "Not Applicable",
    "cvss_vector": "Not Applicable",
    "severity": "Info",
    "url": "",
    "summary": "During the assessment, it was observed that the API does not properly validate or sanitize special characters in APIs inputs.",
    "description": "Input validation is a security control that ensures only expected and safe data is accepted by an API. When input validation is improperly implemented or entirely absent, attackers may submit special characters or payloads that could be misinterpreted or mishandled at a later stage in the API flow.\n\nDuring testing, it was observed that the API endpoints allow an attack to provide malicious input within fields like “x_metadata” and “text” within the Embeddings and PII API endpoints, containing special characters such as <, >, \", ', and / without any filtering or sanitization. While the current behavior does not trigger any injection attacks in the immediate response, however it creates a latent security risk within the application due to the lack thereof.\n\nSuch data, when stored or reflected in another part of the API (e.g., in an admin panel, report viewer, logs, or emails), could be interpreted by a browser or rendering engine and lead to:\n\n•\tStored (second-order) Cross-Site Scripting (XSS) attacks.\n•\tHTML Injection in internal tools or dashboards.\n•\tContext-breaking or layout manipulation in templates or UI components.\n\nThis finding highlights a gap in input validation practices, where untrusted user input is not properly controlled at the entry point, thereby increasing the risk of downstream injection vulnerabilities.",
    "impact": "The lack of proper input validation allows special characters to be submitted via API fields such as “x_metadata and text” creating a latent risk of injection attacks. While no immediate exploitation was observed, this can lead to stored XSS or HTML injection in downstream systems like admin panels or reports, potentially compromising data integrity, user trust, and the security of internal workflows.",
    "recommendation": "It is recommended to implement robust input validation and output encoding mechanisms:\n•\tValidate and restrict user input to only allow characters and formats explicitly required for business logic.\n•\tImplement allowlist-based validation for all user-supplied input across APIs.\n•\tReject or sanitize special characters that are not needed in the input context (e.g., <, >, \").\n•\tApply output encoding (e.g., HTML-encoding, JavaScript-encoding) when displaying user input in any HTML/JS context.",
    "cwe": "",
    "reference": "https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html",
    "steps": []
  },
  {
    "id": "",
    "title": "HTTP Request Smuggling (Client-Side Desync)",
    "cvss": "Not Applicable",
    "cvss_vector": "Not Applicable",
    "severity": "Info",
    "url": "",
    "summary": "During the assessment, it was observed that the APIs are vulnerable to HTTP Request Smuggling.",
    "description": "HTTP Request Smuggling is an attack technique that exploits inconsistencies in parsing HTTP requests between front-end and back-end servers or between intermediaries and clients. A specific variant of this attack, Client-Side Desync occurs when a maliciously crafted HTTP request desynchronizes the client and the server, leading the client to interpret the response incorrectly.\n\nThe attacker was able to downgrade the API’s request protocol from HTTP/2 to HTTP/1.1. The attacker added the request header “Connection: Keep-Alive” and appended an additional HTTP request within the request body. Upon sending this crafted request, the application exhibited desynchronization behavior, resulting in a successful HTTP Request Smuggling (Client-Side Desync) attack wherein the application was responding with multiple responses embedded in one.",
    "impact": "The API’s request parsing flaw allows crafted requests to trigger multiple HTTP responses in a single reply, causing client-side desynchronization. While no sensitive data was exposed, this behavior undermines protocol integrity and may disrupt user experience or lead to session misrouting, posing a risk to API reliability and trust.",
    "recommendation": "It is recommended to implement the following:\n•\tPrevent downgrading of HTTP/2 requests to HTTP/1.1 at the backend unless explicitly required.\n•\tEnsure backend services consistently and strictly parse Content-Length, Host, and Connection headers to avoid request desynchronization.\n•\tReject malformed or pipelined HTTP requests containing multiple embedded HTTP messages within a single request body.\n•\tApply consistent HTTP request parsing logic across all intermediary components including load balancers, reverse proxies, and application servers.",
    "cwe": "",
    "reference": "https://portswigger.net/web-security/request-smuggling/browser/client-side-desync",
    "steps": []
  },
  {
    "id": "",
    "title": "Misconfigured Content Security Policy (CSP)",
    "cvss": "Not Applicable",
    "cvss_vector": "Not Applicable",
    "severity": "Info",
    "url": "",
    "summary": "During the assessment, it was observed that APIs are configured with  vulnerable directives like “unsafe-inline” and “unsafe-eval” within the CSP.",
    "description": "Including unsafe-inline and unsafe-eval in the Content Security Policy (CSP) hampers the effectiveness of CSP by permitting the execution of inline scripts and dynamic code evaluation (e.g., via eval(), setTimeout(), or new Function()). This bypasses CSP’s core mitigation mechanism against cross-site scripting (XSS), enabling threat actors to inject and execute arbitrary JavaScript payloads directly within the browser context, thereby compromising the integrity and confidentiality of client-side data.\n\nIt was observed that the APIs have poorly a poorly configured Content Security Policy (CSP) which uses overly permissive directives such as 'unsafe-inline' or 'unsafe-eval'.\n\nAs a result, an attacker can weaken defenses against cross-site scripting (XSS) and other code injection attacks, enabling them to run malicious scripts, steal sensitive data, or hijack user sessions.",
    "impact": "The use of unsafe directives like unsafe-inline and unsafe-eval in the CSP weakens the browser’s defenses against script-based attacks by permitting inline and dynamic code execution. Although no exploit was observed, the use of these directives lower the security baseline and increases exposure to XSS and code injection risks, potentially impacting client-side data integrity and secure coding standards.",
    "recommendation": "It is recommended to implement the following:\n•\tOnly allow content from your own domain and trusted third parties.\n•\tSpecify all resource types: Define rules for scripts, styles, images, fonts, etc.\n•\tUse nonces or hashes for inline scripts/styles: If you must allow inline scripts, use nonces or hashes for better security.\n•\tTest in report-only mode first: Use Content-Security-Policy-Report-Only to monitor violations before enforcing the policy.",
    "cwe": "",
    "reference": "https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html",
    "steps": []
  },
  {
    "id": "",
    "title": "Concurrent Login Enabled",
    "cvss": "Not Applicable",
    "cvss_vector": "Not Applicable",
    "severity": "Info",
    "url": "",
    "summary": "During the assessment, it was observed that concurrent user sessions in multiple browsers are allowed by the application.",
    "description": "The application allows multiple active sessions using the same user credentials from different devices or locations at the same time, without any session restriction or alerts. This behavior indicates that concurrent logins are enabled, which can pose a significant security risk in environments that require strong user session management and account integrity.\n\nAllowing concurrent sessions weakens user accountability and session control, as it becomes difficult to identify unauthorized access or session hijacking. If user credentials are compromised, an attacker can maintain access without disrupting the legitimate user's session, reducing the likelihood of detection.",
    "impact": "Allowing concurrent logins without restriction weakens session integrity and user accountability, making it difficult to detect unauthorized access or credential compromise. In environments handling sensitive data or requiring strict access controls, this behavior can lead to compliance concerns and increases the risk of undetected misuse of user accounts, potentially undermining trust and data security.",
    "recommendation": "It is recommended to :\n•\tImplement session management controls to restrict concurrent logins per user account, allowing only one active session at a time (or as per policy).\n•\tInvalidate existing sessions when a new login occurs, unless explicitly permitted (e.g., trusted devices or MFA-validated sessions).\n•\tProvide session management features in the user interface (e.g., “Log out of all other devices”).\n•\tAlert users of concurrent session activity, especially if logins occur from new IPs, devices, or locations.\n•\tEnforce session timeouts and idle session expiration to reduce the risk of unauthorized access.\n•\tLog and monitor session activity to detect suspicious concurrent access patterns",
    "cwe": "",
    "reference": "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/11-Testing_for_Concurrent_Sessions",
    "steps": []
  },
  {
    "id": "",
    "title": "HTTP Request Header Tampering",
    "cvss": "Not Applicable",
    "cvss_vector": "Not Applicable",
    "severity": "Info",
    "url": "",
    "summary": "During the assessment, it was observed that the supporting APIs reflects the value of the user-supplied X-Correlation-Id request header in the server’s response without proper validation or sanitization.",
    "description": "The API’s reflects the value of the X-Correlation-ID request header in the HTTP response without proper sanitization and reflects the value as is in the response making it vulnerable to reflected header injection attacks.\n \nBy modifying this header with arbitrary or crafted content, an attacker can influence the server’s response, which may lead to unintended behavior depending on how the value is processed or displayed. The X-Correlation-ID is a custom HTTP header commonly used in distributed systems and microservices to trace and correlate requests across different components for debugging and monitoring purposes. \n\nHowever, when its value is reflected without validation, it introduces a security risk that may compromise the integrity of system behavior, request tracking, and observability.",
    "impact": "Reflecting unsanitized values from the X-Correlation-ID header in server responses compromises the integrity of request tracking and observability mechanisms. This behavior may lead to inaccurate logging, disrupted monitoring, or potential reflected header injection, increasing the risk of downstream misinterpretation, debugging errors, or misuse in chained systems relying on this header for traceability.",
    "recommendation": "It is recommended to implement the following:\n•\tAvoid reflecting user-supplied header values like X-Correlation-ID in HTTP responses unless absolutely necessary.\n•\tValidate the header format strictly (e.g., allow only UUIDs or alphanumeric values).\n•\tSanitize and encode the header value before including it in any response or log output.\n•\tPrefer server-side generation of X-Correlation-ID to ensure consistency and prevent manipulation.\n•\tImplement input filtering to reject suspicious or malformed header values.\nReview and secure all custom headers used in request handling and response generation.",
    "cwe": "",
    "reference": "https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html",
    "steps": []
  },
  {
    "id": "",
    "title": "Missing Security Headers",
    "cvss": "Not Applicable",
    "cvss_vector": "Not Applicable",
    "severity": "Info",
    "url": "",
    "summary": "During the assessment, it was identified that the application does not implement security headers like HSTS, X-Content-Type-Options and X-Frame-Options.",
    "description": "The vulnerability concerns the absence of important security headers in the application's HTTP responses - specifically, Strict-Transport-Security, X-Content-Type-Options, and X-Frame-Options. These headers are essential for enforcing client-side protections against a range of attack vectors. Their absence weakens the browser’s built-in security posture and exposes users to several risks.\n\nUpon inspecting the HTTP responses, it was observed that:\n•\tThe Strict-Transport-Security header (HSTS) was not set, allowing attackers to downgrade HTTPS connections to HTTP and launch man-in-the-middle (MITM) attacks.\n•\tThe X-Content-Type-Options header was missing, which enables MIME type sniffing and can lead to the execution of malicious scripts if a browser misinterprets content types.\n•\tThe X-Frame-Options header was also absent, leaving the application potentially vulnerable to clickjacking attacks by allowing it to be embedded within a malicious iframe.\n\nAs a result of these missing headers, an attacker could:\n•\tPerform protocol downgrade or man-in-the-middle attacks due to the lack of HSTS enforcement.\n•\tExploit MIME type confusion by forcing the browser to incorrectly render scripts or content, potentially leading to cross-site scripting (XSS).\n•\tExecute UI redressing or clickjacking attacks by framing the application within a malicious domain, tricking users into unintended interactions.\n•\tIncrease the likelihood of user data compromise and degrade the overall client-side security controls.",
    "impact": "The absence of critical security headers such as HSTS, X-Content-Type-Options, and X-Frame-Options weakens the browser’s native protections against common client-side attacks. This increases the risk of man-in-the-middle attacks, content type misinterpretation, and clickjacking, potentially compromising user data, degrading trust in the application, and failing to meet industry-standard security and compliance expectations.",
    "recommendation": "To address the absence of the Strict-Transport-Security, X-Content-Type-Options, and X-Frame-Options headers, consider implementing the following recommendations:\nImplement HTTP Strict Transport Security (HSTS)\n•\tAdd the Strict-Transport-Security header to all HTTPS responses.\n•\tStrict-Transport-Security:max-age=31536000; includeSubDomains\n•\tThis instructs browsers to enforce HTTPS for future requests, mitigating the risk of protocol downgrade and man-in-the-middle (MITM) attacks.\n•\tEnsure the site is fully accessible over HTTPS with valid certificates before deploying HSTS.\nImplement X-Content-Type-Options\n•\tAdd the X-Content-Type-Options header with the value nosniff to all HTTP responses.\n•\tX-Content-Type-Options: nosniff\n•\tThis instructs browsers not to perform MIME-type sniffing, helping prevent XSS and drive-by download attacks where content types may be interpreted incorrectly.\nImplement X-Frame-Options\n•\tAdd the X-Frame-Options header to prevent the application from being embedded in iframes on other domains.\n•\tX-Frame-Options: DENY or X-Frame-Options: SAMEORIGIN\n•\tThis mitigates clickjacking attacks by restricting the ability of other sites to frame your content and deceive users into performing unintended actions.",
    "cwe": "",
    "reference": "https://owasp.org/www-project-secure-headers/",
    "steps": []
  },
  {
    "id": "",
    "title": "Version Disclosure",
    "cvss": "Not Applicable",
    "cvss_vector": "Not Applicable",
    "severity": "Info",
    "url": "",
    "summary": "During the assessment, it was identified that the application discloses the versions of core JavaScript libraries such as core-js and mustache.js",
    "description": "Version disclosure occurs when a web application reveals the specific version information of its libraries or components (e.g., JavaScript frameworks, server software, APIs). It can aid an attacker in reconnaissance, enabling them to craft more targeted attacks once a known exploit becomes available.\n\nIt was observed that the application includes JavaScript libraries with version information of core-js and mustache.js clearly visible in the chunk js files used by the server. It was identified that the following versions are disclosed and in use: \n•\tCore.js: 3.39.0\n•\tMustache.js: 4.2.0  \n.\nAt the time of assessments, no public vulnerabilities were found for the disclosed versions. However, disclosed versions can become a security concern if those versions are later found to have vulnerabilities. Attackers often fingerprint applications based on such details and automate scans to detect systems running vulnerable components.",
    "impact": "The disclosure of specific library versions such as core-js and mustache.js provides attackers with intelligence that can be used for targeted exploitation if vulnerabilities are later discovered in those versions. While no known issues exist at present, this increases the application's exposure during automated reconnaissance and may reduce its resilience against future zero-day or known vulnerability exploitation efforts.",
    "recommendation": "To minimize the information exposed to potential attackers, it is recommended to implement the following:\n•\tAvoid disclosing library or framework versions in file names, comments, or HTTP headers.\n•\tMinimize unnecessary exposure of third-party components to public users if not needed.\n•\tMask or minify source code sections that specify sensitive versions or software details.",
    "cwe": "",
    "reference": "https://cwe.mitre.org/data/definitions/200.html",
    "steps": []
  },
  {
    "id": "",
    "title": "Weak Password Policy",
    "cvss": "Not Applicable",
    "cvss_vector": "Not Applicable",
    "severity": "Info",
    "url": "",
    "summary": "During the assessment, it was identified that the application allows the use of weak passwords. ",
    "description": "A weak password policy vulnerability occurs when applications allow users to create easily guessable or crackable passwords, increasing the risk of unauthorized access, data breaches, and other security incidents. \n\nThe application allows an attacker to register a new user under the “Create Account” section which implements a weak password policy. \n\nWithout enforcing minimum password length, complexity requirements (like uppercase, lowercase, numbers, and special characters), or periodic password changes, user accounts become easy targets for brute force or credential stuffing attacks.  \nThis can result in account takeovers, data breaches, and damage to user trust.",
    "impact": "The application’s weak password policy increases the risk of unauthorized access through brute force or credential stuffing attacks. By allowing easily guessable passwords during account creation, it compromises account security, potentially leading to user account takeovers, data exposure, and a loss of trust in the platform’s ability to protect user information.",
    "recommendation": "It is recommended to implement a strong password policy that requires:\n•\tA minimum password length (e.g., at least 8–12 characters)\n•\tInclusion of uppercase and lowercase letters, numbers, and special characters\n•\tRestrictions on commonly used or easily guessable passwords",
    "cwe": "",
    "reference": "https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/04-Authentication_Testing/07-Testing_for_Weak_Password_Policy",
    "steps": []
  }
]
